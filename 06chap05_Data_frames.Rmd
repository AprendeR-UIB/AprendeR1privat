# *Data frames* {#chap:df}

 Habitualmente, dispondremos de una serie de datos que describirán algunos
aspectos de un conjunto de individuos, y querremos analizarlos. El análisis estadístico de estos datos puede ser  de dos tipos básicos:


*  **Análisis exploratorio** , o  **descriptivo** , cuando nuestro objetivo sea resumir, representar y explicar los datos concretos de los que disponemos. La **estadística descriptiva**  es el conjunto de técnicas que se usan con este fin.\index{estadística descriptiva}

* *Análisis inferencial* , si nuestro objetivo es deducir  (**inferir**),  a partir de estos datos,
información significativa sobre el total de la población o las poblaciones de interés.  Las técnicas que se usan en este caso forman la *estadística inferencial*.

En las próximas lecciones explicaremos algunas técnicas básicas de estadística
descriptiva orientadas al análisis de datos. Estas técnicas consistirán en una serie de 
medidas, gráficos y modelos descriptivos que nos permitirán resumir y explorar un conjunto
de datos, con el objetivo final de entenderlos lo mejor posible.
De todas formas, ambos tipos de análisis estadístico están relacionados. Así, por un lado,  cualquier análisis inferencial se suele empezar explorando los datos que se usarán, y por otro, muchas técnicas descriptivas permiten estimar propiedades de la población de la que se ha extraído la muestra. Por citar un ejemplo, la media aritmética de las alturas de una muestra de individuos nos da un valor representativo de esta muestra, pero también *estima*  la media de las alturas del total de la población, si la muestra es aleatoria.


Los datos de los que disponemos para su análisis suelen ser multidimensionales, en el sentido de que
observamos varias características de una serie de individuos. Estos datos
se tienen que registrar de alguna manera. Normalmente, los 
guardaremos en un archivo de ordenador con un formato preestablecido.
Los formatos de almacenamiento de datos en un ordenador son diversos: texto
simple (codificado en diferentes formatos: ASCII, isolatin, utf8...), hojas 
de cálculo(archivos de *Open Office* o *Excel*), bases de datos, etc.
Una de las maneras básicas de almacenar datos es en forma de `tablas
de datos` , pequeñas bases de datos donde se han anotado los valores de algunas variables para una serie de observaciones.

Como ya comentamos en la Lección \@ref(chap:lm), la manera más conveniente de guardar en `R` una tabla de datos  es en forma de  *data frame*.  En concreto, un *data frame* es  una tabla de doble entrada, formada por variables en las columnas y observaciones de estas variables en las filas, de manera que cada fila contiene los valores de las variables para un mismo caso o   individuo. En este sentido, un *data frame* tiene la apariencia de una matriz, pero con la diferencia de que cada columna de un *data frame* puede contener datos de un tipo diferente, siempre que todos los datos de una misma columna sean del mismo tipo, porque corresponden a  observaciones
de una misma propiedad: así, una columna puede estar formada por números, por ejemplo, alguna medida; otra, por palabras, por ejemplo, la especie del individuo; otra, por valores lógicos,  por ejemplo, que describan si una cierta propiedad está presente o ausente en el individuo; etc.  De esta manera, las columnas de un *data frame* son vectores o factores, mientras que las filas son `lists`.

Los tipos de datos que consideramos en este curso son los siguientes:

* Datos de tipo **atributo** , o  **cualitativos**. Son los que expresan una cualidad del
individuo, tales como el sexo, el DNI, la especie... . En `R`, guardaremos las listas de datos cualitativos en vectores (habitualmente, de palabras), o en factores  si vamos a usarlos para clasificar individuos.

* Datos **ordinales**. Son datos similares a los
cualitativos, con la única diferencia de que se pueden ordenar de manera natural.
Por ejemplo, los niveles de calidad ambiental de un ecosistema (malo, regular, normal,
bueno, muy bueno) o las calificaciones en un examen (suspenso, aprobado, 
notable,sobresaliente) son datos ordinales. En cambio, no se pueden ordenar de manera
significativa los sexos o las especies de los individuos. En `R`, guardaremos las listas de datos ordinales en factores ordenados.


* Datos **cuantitativos**. Son datos que se
refieren a medidas, tales como edades, longitudes, pesos, tiempos, números de individuos, etc.  En `R`, guardaremos las listas de datos cuantitativos en vectores de números.

El análisis, tanto descriptivo como inferencial, de un conjunto de  datos es 
diferente según su tipo. Así, para datos cualitativos sólo tiene interés estudiar y representar las frecuencias con que aparecen sus diferentes valores, mientras que el análisis de datos cuantitativos suele involucrar el cálculo de medidas estadísticas que evalúen numéricamente sus propiedades.





## Estructura de un *data frame*

  La instalación básica de `R` lleva predefinidos algunos objetos de datos. 
Podemos echarles un vistazo entrando la instrucción `data()`, que abrirá una ventana con la lista de los objetos de datos a los que tenemos acceso en la sesión actual de `R` (los que lleva la instalación básica de `R` y los que aportan los paquetes que tengamos cargados). Estos objetos no aparecen cuando hacemos `ls()` ni se borran con `rm(list=ls())`, y podemos pedir información sobre cada uno de ellos en la ventana de Ayuda. Al final de la lista que obtenemos con  `data()` se nos indica que si entramos 

`data(package=.packages(all.available=TRUE))`,

obtendremos la lista de `todos`  los objetos de datos a los que tenemos acceso, incluyendo los de  los paquetes  instalados pero no cargados en la sesión actual.




Una de las tablas de datos más populares que lleva `R` es el llamado *iris data set*, que contiene la longitud y la anchura de los pétalos y sépalos y la especie de 150 flores iris. El famoso estadístico Sir R. A. Fisher usó este conjunto de datos  en su artículo <<The Use of Multiple Measurements in Taxonomic Problems>> (`Annals of Eugenics`  7 (1936), pp. 179--188).^[ Se puede descargar de [http://digital.library.adelaide.edu.au/coll/special//fisher/138.pdf](http://digital.library.adelaide.edu.au/coll/special//fisher/138.pdf) .]   En `R`, este conjunto de datos de flores iris está recogido en el *data frame* `iris`.  Para más información sobre estos datos, podéis leer su entrada en la *Wikipedia*,^[ [http://en.wikipedia.org/wiki/Iris_flower_data_set](http://en.wikipedia.org/wiki/Iris_flower_data_set) .]  y para más información específica sobre la tabla `iris` de `R`, podéis consultar la Ayuda de `iris`.

En esta sección vamos a trabajar con esta tabla de datos, así que lo primero que haremos será copiarla en un nuevo 
 *data frame* que llamaremos `d.f`; de este modo trabajaremos sobre la copia `d.f` y  tendremos acceso al *data frame* `iris` original  si necesitamos volver a él. De todas formas, 
si trabajamos directamente sobre `iris` y lo echamos a perder, lo podemos recuperar ejecutando la instrucción `data(iris)`, que devolverá a este *data frame*  su contenido original.
 
 
 
```{r}
d.f=iris
```
Si pidiéramos ahora a `R` que nos mostrase el objeto `d.f`,
```
> d.f
```
obtendríamos el contenido del *data frame* en la consola: una larga lista de datos formada por las 150 filas de la tabla; naturalmente, no vamos a copiar aquí esta salida. Para echarle un vistazo al *data frame*, y así poder entender su estructura y conocer los nombres de sus variables, os recomendamos usar la instrucción

```
> View(d.f)
```
que lo mostrará en la ventana superior izquierda de *RStudio*.
Véase la Figura \@ref(fig:View).



```{r View, fig.cap='Vista de un *data frame* con `View`.',fig.width=1}
knitr::include_graphics("images/View.jpg")
```

<!--

\begin{figure}[htb]
\abovecaptionskip=-1ex
\begin{center}
\includegraphics[width=0.7\linewidth]{View}
\end{center}
\caption{Vista de un *data frame* con `View`.}\label{fig:View}
\end{figure}
-->

También podemos consultar en la consola las primeras filas del *data frame*, aplicando la función `head`  al *data frame* y al número de filas que queremos que muestre; su valor por defecto es 6.

```{r}
head(d.f,5)  #Las primeras 5 filas
```


La función `tail`, con una estructura similar a `head`, nos muestra la <<cola>> de la tabla.

```{r}
tail(d.f,5)    #Las últimas 5 filas
```


Observad que las columnas del *data frame* tienen `nombres`  (`R` los llama `names`) y las filas, que corresponden a individuos, tienen como `identificador`  (`R` llama a estos identificadores `rownames`) un número natural correlativo que va del 1 al 150. Podemos comprobar también que, en cada fila, la columna  `Species` contiene una palabra que describe la especie de la flor, mientras que las otras cuatro columnas contienen números que corresponden a medidas.
Como veremos, la  columna  `Species` no es un vector, sino un factor (con niveles las tres especies de iris: *setosa*, *versicolor* y *virginica*), lo que nos facilita el uso de esta variable para clasificar las flores.

Si queremos conocer la estructura global de un *data frame*, podemos usar la función `str`.

```{r}
str(d.f)
```
El resultado de esta instrucción nos muestra la estructura del objeto `d.f`. Nos dice que es un *data frame* formado por 150 observaciones (filas) de 5 variables (columnas), y de cada variable nos da su nombre (precedido de un signo `$`) y su tipo de datos: las cuatro primeras son variables cuantitativas, formadas por vectores numéricos (`num`), y la quinta es una variable cualitativa, un factor con (`w`, de *with*) 3 niveles que corresponden a las especies. Además, nos muestra los primeros valores de cada variable: en el caso del factor, los unos significan <<setosa>>, su primer nivel.


Las funciones siguientes nos permiten obtener los nombres de las variables, los identificadores de las filas y las dimensiones de un *data frame*:

* `names`: Produce un vector con los nombres de las columnas.
* `rownames`: Produce un vector con los identificadores de las filas.
* `dimnames`: Produce una `list` formada por dos vectores: el de los identificadores de las filas y el de los nombres de las columnas.
* `dim`: Produce un vector con  el número de filas y el número de columnas. 

Veamos sus valores sobre nuestro *data frame*:

```{r}
names(d.f)
rownames(d.f)
dimnames(d.f)
dim(d.f)
```
Fijaos en que el resultado de `rownames` son los identificadores de las filas entre comillas, es decir, considerados como palabras;  `R` entiende siempre que estos identificadores son palabras, aunque, como en este caso, sean números.

Recordaréis que se puede obtener el valor de una componente de una `list` añadiendo al nombre de esta última un sufijo formado por el signo `$` seguido del nombre de la componente. De manera similar,
para obtener una columna concreta de un *data frame* basta añadir a su nombre un sufijo formado por el signo`$`seguido del nombre de la variable; el resultado será un vector o un factor, según cómo esté definida la columna dentro del *data frame*

```{r}
d.f$Sepal.Length[1:30]
d.f$Species[1:30]
```


Como también pasaba con las componentes de las `list`, las variables de un *data frame* son internas, no están definidas en el entorno global de trabajo de `R`.
```
> Sepal.Length 
Error: object 'Sepal.Length' not found
```
En la Sección \@ref(sub:attach) explicaremos cómo podemos declarar las variables internas de un *data frame* como variables globales, y así poder usarlas directamente por su nombre, sin tener que añadirles delante el nombre del *data frame* y el `\$`.


Los *data frames* comparten con las matrices el uso de los corchetes para extraer trozos por filas y columnas. Los resultados que se obtienen son de nuevo *data frames*, y tanto los nombres de las columnas como los identificadores de las filas se heredan del *data frame* original; podemos comprobarlo en los siguientes ejemplos:

```{r}
d.f[1:5, ] #La subtabla de las 5 primeras filas  
d.f[1:5, 1:3]  #La subtabla de las 5 primeras filas y las 3 primeras columnas
d.f[d.f$Species=="virginica" & d.f$Sepal.Length>7, ]  #La subtabla de filas con Species=virginica y Sepal.Length>7
d.f[d.f$Species=="virginica" & d.f$Sepal.Length>7, ][1:4,]  #La subtabla de las 4 primeras filas de la anterior
```
En todos los casos, obtenemos subtablas del *data frame* `d.f` con sus filas y columnas determinadas por las expresiones entre corchetes. 



## Cómo importar y exportar *data frames*

 `R` dispone de varias instrucciones que permiten importar ficheros externos como objetos de datos; por ejemplo, ya vimos en la Lección \@ref(chap:vect) la función `scan`, que permitía 
definir un vector con el contenido de un fichero. En esta sección explicaremos cómo podemos definir un *data frame* a partir de una tabla de datos contenida en un fichero externo. Para ello, usaremos la función `read.table` o  el menú <<*Import Dataset*>> de la pestaña **Environment** de la ventana superior derecha de *RStudio*. En ambos casos, el fichero a importar ha de ser de texto simple: nada de ficheros en formato *doc* o *xls*, 
cuya lectura requiere funciones específicas (página \pageref{page:esp}).

Empecemos con la función `read.table`. Para crear un *data frame* a partir de un fichero de texto simple que contenga una tabla de datos, podemos aplicar esta función al nombre del fichero, si está en el directorio de trabajo de `R`, o a su `url` , si está en Internet; en ambos casos, entre comillas. Esta función `read.table` tiene algunos parámetros  que evitan errores en la creación del *data frame*:

* `sep`. Como ya ocurría con la función `scan`, la función `read.table` entiende por defecto que las separaciones entre columnas en el fichero están marcadas por espacios en blanco. Si esta separación está marcada  por comas, signos de punto y coma,  tabuladores o de cualquier otra manera, hay que especificarlo con este parámetro.

Por ejemplo, tenemos que especificar `sep=","` para indicar que las separaciones entre columnas son comas,
 `sep=";"` para indicar que las separaciones entre columnas son signos de punto y coma,
 y  `sep="\t"` para indicar que las separaciones entre columnas son tabuladores.

* `header`. Si la tabla que importamos tiene una primera fila con los nombres de las columnas, es conveniente especificarlo con el parámetro `header=TRUE`; en caso contrario, y según cómo esté formateado el fichero, puede que `R` entienda la fila de los nombres de las variables como la primera fila de observaciones. 
Si, en cambio, las columnas de la tabla que importamos no tienen nombre, no hace falta especificar el parámetro `header` (o usar `header=FALSE`, que es su valor por defecto), y después  ya pondremos nombres a las variables con la función `names` (véase la Sección \@ref(sec:moddf)).

* `dec`. Como ya explicamos en la función `scan`, podemos usar el parámetro `dec` para especificar el separador decimal, si no es un punto.

* `stringsAsFactors`.  Por defecto, `read.table` transforma  en factores las columnas de palabras de la tabla que importa. Para impedir esta transformación, de manera que los vectores de palabras se importen como tales, podemos usar `stringsAsFactors=FALSE`.

* `encoding`. Como también ya explicamos en la función `scan` (página \pageref{page:encoding}), este parámetro sirve para indicar la codificación de alfabeto del fichero que se va a importar, y se ha de usar si dicho fichero contiene palabras con letras acentuadas o caracteres especiales y su codificación no coincide con la que espera nuestro ordenador: lo notaremos porque si importamos el fichero sin especificar este parámetro, los acentos se  importan mal. Como los ficheros externos que usamos en este curso están codificados en utf8, los  usuarios de Windows de vez en cuando tendrán que usar  `encoding="latin1"`. Avisaremos cada vez que sea necesario.

Para otros parámetros, podéis consultar la Ayuda de `read.table`. 

Vamos a ilustrar el uso de esta función. Descargad en vuestro directorio de trabajo de `R` los dos ficheros siguientes, manteniendo sus nombres y extensiones:

[http://aprender.uib.es/Rdir/NotaHermanos.txt](http://aprender.uib.es/Rdir/NotaHermanos.txt)
[http://aprender.uib.es/Rdir/NotaHermanosc.txt](http://aprender.uib.es/Rdir/NotaHermanosc.txt) 


Ambos ficheros son básicamente la misma tabla de datos, que recoge, para algunos estudiantes de primer curso  de la UIB de hace unos años, el grado en el que estaban matriculados (Biología, <<BL>>, o Bioquímica, <<BQ>>), su número de hermanos y la nota que obtuvieron en un determinado examen; la diferencia  es que, en el primero, las columnas están separadas por espacios en blanco, y en el segundo, por comas. Ambos ficheros contienen una primera fila con los nombres de las variables. Están codificados en utf8, pero como no contienen letras acentuadas ni caracteres especiales, no tenéis que preocuparos por su codificación.

Para crear un *data frame* llamado `NH1` a partir de la copia local del fichero `NotaHermanos.txt`, basta aplicar la función `read.table` a su nombre entre comillas y especificar `header=TRUE`.

```{r}
NH1=read.table("NotaHermanos.txt", header=TRUE)
```


Es una buena costumbre, una vez definido un *data frame* a partir de un fichero externo, comprobar que se ha importado bien.
Como una tabla de datos puede tener muchas filas, verla entera en la consola puede ser poco práctico; lo mejor es  
usar las funciones `str` y `View` o `head`. Os aconsejamos que, siempre que vayáis a trabajar con un *data frame*, le echéis antes un vistazo con estas funciones para comprobar su estructura, los nombres de sus variables, los tipos de sus datos, etc. Esto es especialmente importante cuando se trata de *data frames* importados, porque si no hemos especificado los parámetros adecuados, puede que en el proceso de lectura y definición del *data frame* se hayan perdido los nombres de las variables o la estructura de columnas.
```{r}
head(NH1)
str(NH1)
```


Si no hubiéramos especificado `header=TRUE`, el formato del *data frame* resultante no habría sido el adecuado.

```{r}
NH1.mal=read.table("NotaHermanos.txt")
str(NH1.mal)
```
Sin el parámetro `header=TRUE`, `R` ha entendido que
`Grado`, `Hermanos` y `Nota` son elementos de sus columnas respectivas, y no sus nombres; en consecuencia, por un lado, ha llamado por defecto `V1`, `V2` y `V3` a las columnas del *data frame*, y por otro, como 
`Grado`, `Hermanos` y `Nota` son palabras y los datos de cada variable de un *data frame* han de ser del mismo tipo, ha considerado que todas las entradas de cada columna eran palabras. Finalmente, como, al crear un *data frame*, `R` interpreta los vectores de palabras como factores si no especificamos lo contrario, hemos obtenido un *data frame* formado por tres factores, y hemos perdido la información numérica que contenían las columnas con el número de hermanos y la nota.

Para importar el fichero `NotaHermanosc.txt`, donde las columnas están separadas por comas,
hay que usar el parámetro `sep=","`.

```{r}
NH2=read.table("NotaHermanosc.txt", header=TRUE, sep=",")
str(NH2)
```
Sin este parámetro, `R` hubiera entendido cada fila como una sola palabra.

```{r}
NH2.mal=read.table("NotaHermanosc.txt", header=TRUE)
str(NH2.mal)
```
Veamos el efecto de `stringsAsFactors=FALSE`:

```{r}
NH3=read.table("NotaHermanosc.txt", header=TRUE, sep=",", stringsAsFactors=FALSE)
str(NH3)
```
La variable `Grado` se ha importado como un vector de palabras:  lo indica el `chr`, de `character`, en la fila correspondiente del resultado de `str`.

Para importar las versiones de Internet de estos ficheros, tendríamos que usar las mismas instrucciones, cambiando el nombre del fichero por su `url` , siempre entre comillas. Por ejemplo:


```{r}
NH4=read.table("http://aprender.uib.es/Rdir/NotaHermanos.txt", header=TRUE)
str(NH4)
```
Naturalmente, para poder importar un fichero de Internet, hay que estar conectados a Internet, el servidor que aloja el fichero tiene que funcionar, y además  no tiene que requerir una palabra clave para acceder.

```{r ID, fig.cap='Importador de tablas de datos del `Rstudio`.', out.width='80%', fig.asp=.75, fig.align='center',echo=FALSE}
knitr::include_graphics("images/figID.png")
```
<!--
\begin{figure}[htb]
\abovecaptionskip=-1ex
\begin{center}
\includegraphics[width=0.6\linewidth]{figID}
\end{center}
\caption{Importador de tablas de datos del `Rstudio`.}\label{fig:ID}
\end{figure}
-->

El menú <<*Import Dataset*>>, de la pestaña **Environment** o del menú <<*Tools*>>, es  equivalente a la función `read.table` para ficheros que contengan tablas de datos de formatos sencillos. Al seleccionar dicho menú, se nos permite entrar un `url`  o navegar por el ordenador para escoger el fichero. Al hacerlo, se abre una ventana como la de la Figura \@ref(fig:ID) donde, entre otras acciones:

* Podemos poner nombre al *data frame* (en el campo `Name` ).
* Podemos especificar la codificación de alfabeto del fichero (en el campo `Encoding` ).
* Podemos indicar si tiene una primera fila con los nombres de las variables (en el campo `Heading` ).
* Podemos especificar el signo que separa las columnas (en el campo `Separator` ) y el signo que separa la parte entera de la decimal (en el campo `Decimal` ).
* Podemos indicar si los vectores de palabras se han de convertir en factores (marcándolo en `Strings as factors` ).

La ventaja de este menú es que en su campo superior derecho vemos el fichero original, lo que nos ayuda a rellenar los campos anteriores, y en el inferior derecho vemos el aspecto del *data frame* que creamos con nuestras elecciones. Su inconveniente es que, si queremos que nuestro análisis de datos sea reproducible por otras personas, es necesario incluir en el guión que publiquemos la función `read.table` con los parámetros exactos que hemos usado. 


Además de `read.table`, que sólo sirve para importar tablas en formato texto simple, 
`R` dispone de otras  instrucciones similares
para importar otros tipos de ficheros. Las más útiles son:\label{page:esp}

* `read.csv`, para importar ficheros en formato CSV.
* `read.xls`  y `read.xlsx`, del paquete `xlsx`, para importar hojas de cálculo tipo *Excel* u *OpenOffice* en formato XLS o XLSX, respectivamente. Estas funciones usan Java; si no lo tenéis instalado y no lo queréis instalar, lo mejor es que guardéis la hoja de cálculo en formato CSV (tanto *Excel* como *OpenOffice* o *Numbers* ofrecen esta posibilidad) y uséis `read.csv`.
* `read.mtb` y `read.spss`, del paquete `foreign`, para importar tablas de datos de Minitab y SPSS, respectivamente.

Si necesitáis otras funciones de este tipo, entrad `help.search(read)`, buscad  la función que  os convenga y consultad su Ayuda.

Podemos exportar un *data frame*  a un fichero usando la función `write.table`. Su sintaxis básica es
`write.table(, file="nombre del fichero")`.

Esta función crea un fichero, en el directorio de trabajo de `R`, que contiene el *data frame* que hemos especificado en el argumento, y lo llama el  nombre  que hemos especificado en `file`. Además, podemos usar el parámetro `sep` para indicar el signo de separación de columnas en el fichero que creemos y el parámetro `dec` para indicar el separador decimal; por ejemplo,

```{r}
A=iris[1:5, 1:4]
A
write.table(A, file="trozoiris.txt")
```
guarda el *data frame* $A$ en un fichero llamado `trozoiris.txt`. Ahora podemos volver a importar este fichero.

```{r}
B=read.table("trozoiris.txt", header=TRUE)   #Importamos la tabla
B
```



## Cómo crear *data frames*

  Además de trabajar con *data frames* importados o predefinidos, también podemos crearlos; para ello, organizaremos en forma de tabla algunos vectores, cada uno de los cuales contendrá las observaciones de una variable para un conjunto de individuos o casos, y de manera que los datos en todos estos vectores estén en el mismo orden de los individuos: es decir, que la primera entrada de cada vector corresponda a un mismo individuo, la segunda entrada de cada vector corresponda a otro mismo individuo, y así sucesivamente.

Para construir un *data frame* a partir de unos vectores, se usa la función `data.frame` aplicada a los vectores en el orden en el que queramos disponer las columnas de la tabla;
de esta manera, las variables tomarán los nombres de los vectores. Estos nombres también se pueden especificar en el argumento de  la función `data.frame`, entrando cada columna con una construcción de la forma
 
 *Nombre de la variable*`=`*Vector con el contenido de la variable*.
 

Vamos a ilustrar esta función con un ejemplo sencillo, que arrastraremos durante buena parte de lo que queda de lección. Vamos a construir un *data frame* que contenga algunos datos sobre estudiantes; concretamente, este *data frame* tendrá tres variables: una primera columna con el sexo del estudiante, la segunda columna con su edad en años y la tercera con su número de hermanos.


```{r}
Sexo=c("Hombre","Hombre","Mujer","Hombre","Hombre",
   "Hombre","Mujer")
Edad=c(17,18,20,18,18,18,19)
Hermanos=c(2,0,0,1,1,1,0)
d.f1=data.frame(Sexo, Edad, Hermanos)
d.f1
```


Puesto que iremos modificando este *data frame*, vamos a guardar una copia de seguridad (un *backup*) en `d.f1bk` para poder recuperar su estado original si lo necesitamos.

```{r}
d.f1bk=d.f1
```
Es muy prudente y recomendable que guardéis siempre copias de seguridad de los *data frames*  que generéis si vais a manipularlos, porque hay cambios en un *data frame* que son irreversibles y, por lo tanto, si os arrepentís de haber hecho algún cambio, bien podría ser que no lo pudierais deshacer. 

Vamos a consultar  algunas características del *data frame*  `d.f1`.

```{r}
str(d.f1)
rownames(d.f1)
```
Vemos que la primera variable es un factor con dos niveles, y las otras dos son vectores  numéricos (`num`). Vemos también que `R` ha asignado como identificadores  de las filas los números del 1 al 7, pero los considera palabras. 

La función `data.frame` dispone de algunos parámetros que permiten ajustar a nuestras necesidades el *data frame* que creamos. Los más útiles son los siguientes:


* `row.names`. Sirve para especificar los identificadores de las filas.

* `stringsAsFactors`. Por defecto, `data.frame` convierte los vectores de palabras en factores. Con `stringsAsFactors=FALSE`, imponemos que los vectores de palabras se mantengan como tales en el *data frame*

Veamos un ejemplo de aplicación de estos dos parámetros.

```{r}
d.f2=data.frame(Sexo, Edad, Hermanos, stringsAsFactors=FALSE, 
  row.names=c("E1","E2","E3","E4","E5","E6","E7"))
d.f2
str(d.f2)
d.f2$Sexo
```
Como vemos, el efecto de `stringsAsFactors=FALSE` ha sido que la variable `sexo` es ahora un vector de palabras, y el del parámetro `row.names` ha sido llamar  `E1,E2,...,E7` a las filas.

Si hemos asignado identificadores a las filas, podemos usarlos para extraer subtablas del *data frame* (aunque también podemos seguir usando los números de las filas). Recordad que, si usáis los identificadores, como son palabras, hay que escribirlos entre comillas.

```{r}
d.f2[c("E1","E2"), ] #Subtabla con las filas E1 y E2
```


Otra manera de crear un *data frame* con `R` es usando el editor de datos del que ya hemos hablado en la Lección \@ref(chap:vect).^[El uso del editor de `Rstudio`  para manipular *data frames* posiblemente requiera la instalación de algún programa auxiliar; por ejemplo, en el caso del Mac OS X, se tiene que tener instalada la última versión de *XQuartz*, que será el programa en el que se abrirá el editor. El  instalador de *XQuartz* se puede descargar de [http://xquartz.macosforge.org](http://xquartz.macosforge.org).]  
  Recordaréis que, para abrir un objeto de datos con este editor, se le aplica la función `fix`. `R` abre entonces el objeto en una nueva ventana de edición. Los cambios que realicemos en un objeto con el editor de datos se guardarán cuando cerremos esta ventana. 

Para crear un *data frame* con el editor de datos, lo primero que hay que hacer es crear un *data frame* con la primera fila, y luego abrirlo con el editor para ir añadiendo filas (y columnas, si se desea). La apariencia exacta de esta ventana y la manera de editar el *data frame* dependen de la interfaz de `R` que se use; por ejemplo, en el `Rstudio` de Mac OS X, entraríamos

```
d.f3=data.frame(Sexo=c("Hombre"), Edad=c(17), Hermanos=c(2))
fix(d.f3)
```
y se abriría la ventana que muestra la  Figura \@ref(fig:edit). 




```{r edit, fig.cap='Editor de *data frames*  de `Rstudio` en  Mac OS X.', out.width='80%', fig.asp=.75, fig.align='center',echo=FALSE}
knitr::include_graphics("images/dataeditordf2.png")
```
<!--
\begin{figure}[htb]
\abovecaptionskip=-1ex
\begin{center}
\includegraphics[width=0.5\linewidth]{dataeditordf2.pdf}
\end{center}
\caption{Editor de *data frames* \ del `Rstudio` de Mac OS X.}\label{fig:edit}
\end{figure}
-->

## Cómo modificar un *data frame* {#sec:moddf}

 En esta sección veremos la manera de modificar un *data frame* una vez creado o importado.

Para cambiar los nombres de las variables, podemos usar la instrucción

`names(`*data frame*`)=`*vector con los nombres de las variables*.


Volvamos al `d.f1`. Tras recordar su estructura, cambiaremos los nombres de sus variables, sustituyéndolos por sus iniciales, y volveremos a consultar su estructura para ver cómo han cambiado estos nombres.

```{r}
str(d.f1)
names(d.f1)=c("S","E","H")
str(d.f1)
```


Si sólo queremos cambiar el nombre de algunas variables, basta redefinir el trozo correspondiente del vector `names`. Así, si en la nueva copia de `d.f1` queremos volver a cambiar el nombre de la variable `E` por `Edad`, podríamos usar una de las dos instrucciones siguientes:

`names(d.f1)[2]="Edad"` o `names(d.f1)[names(d.f1)=="E"]="Edad"`.

Con la primera, cambiaríamos el nombre de la segunda variable por `Edad`; con la segunda, 
cambiaríamos el nombre de la variable llamada `E` por `Edad`.


Para modificar los identificadores de las filas, podemos usar la instrucción

`rownames(`*data frame*`)=`*vector con los nombres de las filas*.

Como cada identificador ha de determinar el individuo al que corresponde la fila, conviene que estos identificadores sean todos diferentes.

```{r}
rownames(d.f1)=paste("Alumno", 1:7, sep=" ")
d.f1
```


Como podéis deducir de su efecto, la función `paste` *pega*  vectores, entrada a entrada, usando como separador el valor del parámetro `sep`; el separador por defecto es un espacio en blanco, por lo que no hubiera hecho falta especificarlo, lo hemos hecho sólo para mostrar el parámetro. Si en lugar de pegar un vector pegamos un elemento, éste se entiende como un vector constante formado por el número adecuado de copias. 

Podemos modificar los nombres de las filas y de las columnas simultáneamente con la instrucción

`dimnames(`*dataframe*`)=list(`*vector con los nombres de las filas*, *vector con los nombres de las columnas*`)`.

Por ejemplo, vamos a cambiar de golpe en `d.f1` los identificadores de las filas, para que ahora sean números romanos, y los nombres de las variables, para que pasen a ser `V1,V2,V3`:

```{r}
dimnames(d.f1)=list(c("I","II","III","IV","V","VI","VII"), 
  c("V1","V2","V3"))
d.f1
```


Para modificar entradas concretas de un *data frame*, podemos usar el editor de datos que se abre con `fix`, o  podemos usar instrucciones similares a las que usábamos en los vectores y las matrices para modificar entradas.

```{r}
d.f1=d.f1bk #Volvemos a la copia guardada
d.f1[1,2]="Joven" #Sustituimos la entrada (1,2) por la palabra   "Joven"
str(d.f1)
```
¡Vaya! Al introducir un dato de tipo palabra en la variable `Edad`, toda la columna ha pasado a ser un vector de palabras: recordemos que `R` considera del mismo tipo de datos todas las entradas de una columna de un *data frame*; y ahora ya no lo podemos arreglar volviendo a poner un número:

```{r}
d.f1[1,2]=17
str(d.f1)
```
Parece que hemos estropeado definitivamente el *data frame* `d.f1`. Pero no es así: simplemente tenemos que volver a redefinir la variable  `Edad` como un vector numérico. 



Para modificar una columna entera, hay que igualar su nombre
 (que, recordemos, se especifica añadiendo al nombre del *data frame* el sufijo formado por el signo `$` seguido del nombre de la variable dentro del *data frame*) a su nuevo valor: 
 
*data frame*`$`*variable*`=`*nuevo valor*`. 

Este nuevo valor puede ser el resultado de un cambio de tipo de datos aplicado a la variable.
`R` dispone de una serie de funciones de la forma `as.tipo_de_objeto`, que convierten el objeto al tipo que expresa el nombre de la función. Ya hemos visto en la Sección \@ref(subsec:factor) la función `as.factor`, que transforma un vector en un factor. Otras funciones de este estilo son 
`as.character`, `as.integer` o `as.numeric`, que transforman todos los datos de un objeto en palabras, números enteros o números reales, respectivamente.

Así, para transformar la variable `Edad` de la última versión estropeada de `d.f1` en un vector numérico,  basta entrar lo siguiente:

```{r}
d.f1$Edad=as.numeric(d.f1$Edad)
str(d.f1)
```


Un error típico al intentar modificar la variable `Edad` es entrar sólo `as.numeric(d.f1$Edad)`; con esta instrucción, obtenemos como resultado el vector $17,18, 20, 18, 18, 18, 19$,
pero no se modifica la variable `Edad` del *data frame* 
Tampoco sirve entrar `Edad=as.numeric(d.f1$Edad)`, porque esto define un vector   llamado `Edad` de entradas $17,18, 20, 18, 18, 18, 19$, pero sigue sin modificar la variable `Edad` del *data frame* La manera correcta de hacerlo es mediante 

*data frame*`$`*variable* `=`*nuevo valor* . 


Veamos otros ejemplos. Vamos a convertir la variable `Sexo` en un vector de palabras:

```{r}
d.f1$Sexo=as.character(d.f1$Sexo)
str(d.f1)
```
Y ahora vamos a convertir la variable `Hermanos` en un factor ordenado:

```{r}
d.f1$Hermanos=ordered(d.f1$Hermanos, levels=c(0,1,2))
str(d.f1)
```


Naturalmente, podemos cambiar el contenido de toda una variable de otras maneras que no sea sólo modificar su tipo de datos:  
basta igualarla a su nuevo valor.

```{r}
d.f1$Edad="Joven"
d.f1
```
Al igualar la variable `Edad` a la palabra <<Joven>>, la ha substituido por el correspondiente vector constante.


## Cómo añadir filas y columnas a un *data frame* {#sec:dfaf}

 Podemos añadir filas a un *data frame* definiéndolas con *data frame*`[`*fila*` , ]=c(...)`; pero esta construcción no es muy recomendable, porque si no vamos con cuidado puede provocar resultados no deseados:


* Las filas que añadimos de esta manera son vectores, y por lo tanto sus entradas han de ser todas del mismo tipo. Por consiguiente, esta opción sólo se puede usar en *data frames* cuyas variables contengan todas el mismo tipo de datos.

* Si no añadimos las filas inmediatamente siguientes a la última del *data frame*, los valores entre su última fila y las que añadimos quedarán no definidos, y aparecerán como `NA`; esto puede ser un problema a la hora de aplicar funciones al *data frame* y además estropea los factores.

La mejor manera de añadir filas a un *data frame* es organizándolas en un nuevo *data frame* con los mismos nombres de las variables, y a continuación concatenarlas al *data frame* usando la función `rbind` que ya usábamos para matrices.

```{r}
d.f1=d.f1bk  #Volvemos a la copia original
d.f1
nuevas.filas=data.frame(Sexo=c("Hombre","Hombre"), Edad=c(18,18), 
  Hermanos=c(1,2))
d.f1=rbind(d.f1, nuevas.filas)
d.f1
str(d.f1)   #Los tipos de las variables no han cambiado
```

Para añadir una variable, basta especificar el valor de la columna correspondiente; por ejemplo, vamos a añadir a  `d.f1` una nueva variable llamada `Nueva` con el producto de la edad por el número de hermanos:

```{r}
d.f1$Nueva=d.f1$Edad*d.f1$Hermanos
d.f1
```


También podemos concatenar columnas a un *data frame*  usando la función `cbind`; en este caso, se puede añadir directamente la columna, sin necesidad de convertirla previamente en un *data frame* La variable añadida ha de tener la misma longitud que las variables del *data frame* original; en caso contrario, se añadirán valores `NA` a las variables del *data frame* original o a la variable que añadimos hasta completar la misma longitud. 

```{r}
d.f1=cbind(d.f1, Grado=rep("Biología",9))
d.f1
str(d.f1)
```


Finalmente, hay que recordar que también podemos usar el editor de datos para añadir (o eliminar) filas o columnas a un *data frame*


## Cómo seleccionar trozos de un *data frame*

 Veamos ahora con más detalle cómo podemos extraer trozos de un *data frame*; el método básico es similar al que usábamos en las matrices. De hecho, para seleccionar un trozo de un *data frame*, podemos hacerlo exactamente como en las matrices, especificando los índices de las filas y columnas que nos interesen dentro de corchetes `[ , ]`. Pero como los individuos y las variables tienen nombres, también podemos usarlos para especificar filas y columnas.

Por ejemplo, supongamos que queremos crear un nuevo  *data frame* formado por las dos primeras filas de `d.f1`; podríamos hacerlo, al menos, de las tres maneras siguientes:

```{r}
d.f1=d.f1bk  #Volvemos a la copia original
d.f1[1:2, ]   #Con los índices de las filas
d.f1[c("1","2"), ]   #Con los identificadores de las filas
d.f1[rownames(d.f1)[1:2], ]   #Con un subvector del vector de identificadores de las filas
```


Podemos usar este tipo de instrucciones para obtener las filas en un orden diferente del que presentan en el *data frame* original. 

```{r}
d.f1[c(2,3,1), ]
```


También podemos seleccionar filas de un *data frame* mediante una condición lógica; en este caso, nos quedaremos sólo con los individuos que satisfagan esta condición. Por ejemplo, si queremos seleccionar los estudiantes de `d.f1` de menos de 19 años, podemos usar la construcción siguiente:

```{r}
d.f1[d.f1$Edad<19, ]
```


Esta condición lógica puede involucrar más de una variable.

```{r}
d.f1[d.f1$Edad<19 & d.f1$Hermanos==1, ]
```


En cada caso, hemos obtenido un *data frame* Vamos a llamar `d.f.18` al primero.

```{r}
d.f.18=d.f1[d.f1$Edad<19, ]
d.f.18
str(d.f.18)
```


Como vemos, las columnas que son factores heredan en estos sub *data frames* todos los niveles del factor original, aunque no aparezcan en el trozo que hemos extraído. Podemos borrar los niveles sobrantes de todos los  factores redefiniendo el *data frame* como el resultado de aplicarle la función 
`droplevels`.

```{r}
d.f.18=droplevels(d.f.18)
str(d.f.18)
```


Naturalmente, el mismo tipo de construcción se puede utilizar para definir un *data frame* formado sólo por algunas variables de la tabla original, o incluso por sólo algunas filas y columnas. Si sólo queremos definir la subtabla quedándonos con algunas variables, basta aplicar el nombre del *data frame* al vector de variables (sin necesidad de dejar el espacio en blanco seguido de una coma que serviría para indicar que nos referimos a columnas y no a filas); por ejemplo, con las cuatro instrucciones siguientes obtenemos cada vez el mismo resultado, un *data frame* formado por las dos primeras variables de `d.f1`:

```{r}
d.f1[ , c(1,2)]  #Con la coma
d.f1[c(1,2)]   #Sin la coma
d.f1[-3]   #Eliminamos la tercera columna
d.f1[c("Sexo","Edad")] #Especificamos los nombres
```


Esta construcción se puede usar también para reordenar las columnas de un *data frame*  ; por ejemplo:

```{r}
d.f1=d.f1[c("Edad","Hermanos","Sexo")]
d.f1
```


El paquete `dplyr` incluye la función `select` que amplía las posibilidades para especificar las variables que queremos extraer de un *data frame*; por ejemplo:

* `select(`*data frame*`, starts_with("x"))` extrae del *data frame*    las variables cuyo nombre empieza con la palabra `x`.
* `select(`*data frame*`, ends_with("x"))` extrae del *data frame*    las variables cuyo nombre termina con la palabra `x`.
* `select(`*data frame*`, contains("x"))` extrae del *data frame*    las variables cuyo nombre contiene en algún sitio la palabra `x`.

```{r}
#Instalamos y cargamos el paquete "dplyr"
#...
library(dplyr)
iris_Petal=select(iris, starts_with("Petal"))
head(iris_Petal, 4)
iris_Length=select(iris, ends_with("Length"))
head(iris_Length, 4)
```
Para más información sobre otras habilidades de la función `select`, podéis consultar su Ayuda.


Como podéis constatar, hay muchas maneras de extraer una misma subtabla de un *data frame* dado; 
veamos una última posibilidad, usando la función `subset`. La instrucción

`subset(`*dta frame*`,` *condición* `, select=` *columnas* `)`

extrae del *data frame* las filas que cumplen la `condición` y las columnas especificadas en el `select`; si queremos todas las filas, no hay que especificar ninguna condición, y  si queremos  todas las columnas, no hace falta especificar el parámetro `select`.
Así, si del *data frame* `iris` queremos extraer un *data frame* formado sólo por las plantas de especie `virginica`, podemos usar la instrucción siguiente:

```{r}
iris.vir=subset(iris, Species=="virginica")
head(iris.vir, 5)
```
Fijaos en que las variables en  la `condición`  se especifican con su nombre, sin añadir antes el nombre del *data frame* 

En este *data frame*, la variable `Species` es redundante, porque todos los individuos toman el mismo valor; por lo tanto, podríamos haberla eliminado al construirlo.

```{r}
iris.vir=subset(iris, Species=="virginica", select=1:4)
head(iris.vir, 5)
```
Las filas de este *data frame* han heredado los identificadores del *data frame* `iris`. Si esto nos molesta, los podemos cambiar.

```{r}
rownames(iris.vir)=1:length(rownames(iris.vir))
head(iris.vir, 5)
```


## Cómo aplicar una función a las variables de un *data frame*

 La mejor manera de aplicar una función a todas las columnas de un *data frame* en un solo paso es por medio de la instrucción

`sapply(`*data frame*`, FUN=`*función* `)`.

A modo de ejemplo, vamos a aplicar algunas funciones a las columnas numéricas del *data frame* `iris`:

```{r}
str(iris)
sapply(iris[ ,1:4], FUN=mean) #Medias de las variables numéricas
sapply(iris[ ,1:4], FUN=sum) #Sumas de las variables numéricas
f=function(x){sqrt(sum(x^2))} 
sapply(iris[ ,1:4], FUN=f) #Normas euclídeas de las variables    numéricas
```


Es conveniente añadir en el argumento de `sapply` el parámetro `na.rm=TRUE`, sin el cual el valor que devolverá la función para las columnas que contengan algún  `NA` será `NA`.

```{r}
D=data.frame(V1=c(1,2,NA,3), V2=c(2,5,2,NA))
D
sapply(D, FUN=mean)
sapply(D, FUN=mean, na.rm=TRUE)
```


A menudo querremos aplicar una función a variables de un *data frame* clasificadas por los niveles de un, o más de un, factor; esto se puede hacer con la instrucción `aggregate`, cuya sintaxis básica es

`aggregate(`*variable(s)*`~`*factor(es)*`, data=`*data frame*`, FUN=`*función*`)`.

El resultado será un *data frame*

Por ejemplo, si queremos calcular las medias de las longitudes de los pétalos de las flores de cada una de las tres especies representadas en la tabla `iris`, podemos entrar la instrucción siguiente:

```{r}
aggregate(Petal.Length~Species, data=iris, FUN=mean, na.rm=TRUE)
```
Hemos añadido `na.rm=TRUE` dentro del `aggregate` para que no tenga en cuenta los `NA` al calcular la media, por si acaso. Observad que el resultado es un *data frame* con variables `Species` y `Petal.Length`. Cada fila corresponde a un nivel del factor  `Species`.



Si queremos aplicar la función a más de una variable,  tenemos que agruparlas a la izquierda de la tilde con `cbind`.

```{r}
aggregate(cbind(Petal.Length, Petal.Width)~Species, data=iris,
          FUN=mean)
```


Si queremos separar las variables mediante más de un factor,  tenemos que agruparlos a la derecha de la tilde con signos `+`: *factor1*`+`*factor2*`+`... . Veamos un ejemplo.
El paquete `alr4` contiene la tabla de datos `Rateprof`, con los resultados globales de la evaluación de un grupo de profesores  universitarios por parte de sus estudiantes. Algunas de sus variables son: `gender`, el sexo del profesor; `pepper`, que indica si en las encuestas se le ha considerado mayoritariamente atractivo o no; y `clarity` y `easiness`, que valoran, entre 1 y 5, la claridad de exposición y la accesibilidad del profesor, respectivamente. Vamos a calcular las medias de estas dos  últimas variables agrupándolas por sexo y atractivo.

```{r}
#Instalamos y cargamos el paquete "alr4"
#...
library(alr4)
aggregate(cbind(clarity,easiness)~gender+pepper, data=Rateprof, FUN=mean)
```
Observamos que tanto la claridad como la accesibilidad medias de los profesores atractivos de ambos sexos son considerablemente mayores que las de sus colegas considerados no atractivos. Además, en promedio, se considera a los profesores  no atractivos menos accesibles que a las profesoras no atractivas, y  a 
los profesores atractivos  `más`  accesibles que a las profesoras atractivas. 

## Cómo añadir las variables de un *data frame* al entorno global {#sub:attach}

 Hasta ahora, cada vez que  queríamos referirnos a una variable de un *data frame*, teníamos que escribir el nombre del *data frame* seguido de `$` y el nombre de la variable. Aplicando `attach` a un *data frame*, hacemos que `R` entienda sus variables como globales y que las podamos usar por su nombre, sin necesidad de añadir delante el nombre del *data frame* y el signo `$`; esto puede ser útil  para no tener que escribir mucho.


A modo de ejemplo, vamos a añadir las variables del *data frame* `iris` al entorno global de `R`:


```
> Petal.Length
Error: objeto 'Petal.Length' no encontrado
```
```{r}
attach(iris)
Petal.Length[1:30]
```
Si ya hubiera existido una variable definida con el mismo nombre que una variable del *data frame* al que aplicamos `attach`, hubiéramos obtenido un mensaje de error al ejecutar esta función, y no se hubiera reescrito la variable global original.

La función `detach` devuelve la situación original, eliminando del entorno global las variables del *data frame*

```
> detach(iris)
> Petal.Length
Error: object 'Petal.Length' not found
```

## <<*Big data*>> *frames* con `data.table` (opcional).

 Aunque  la manera usual de trabajar en `R` con  tablas de datos es en forma de *data frame*,  
su estructura interna los hace poco eficientes a la hora de manejar las tablas de datos de millones de entradas que empiezan a ser habituales en estos tiempos de proyectos *big data*.
Una solución es usar la clase de objetos para definir tablas de datos que incorpora el paquete  `data.table`; para distinguirlos de los *data frame*,  llamaremos a estos objetos *data tables*. 

Un *data table* vendría a ser un *data frame* enriquecido, con la particularidad de que sus filas no tienen   identificadores; en particular  se pueden usar con ellos todas las construcciones y funciones para *data frames* , pero esto no es lo recomendable, puesto que entonces no se gana nada usándolos. Los *data tables* ofrecen unas construcciones específicas para extraer subtablas, añadir, borrar o modificar variables, y aplicar operaciones a variables, que son mucho más eficientes que las propias de los  *data frames* ; su sintaxis es muy diferente de la usada en matrices o *data frames* , pero vale la pena <<cambiar el chip>> si necesitáis trabajar con tablas realmente grandes.

Se puede crear un  *data table* de varias maneras:

* Aplicando la función  `data.table` a un conjunto de vectores, exactamente igual como si usáramos `data.frame`.
* Aplicando la función  `data.table` a un *data frame* Como hemos comentado, las filas de los *data tables* no tienen identificadores; si las del *data frame*  tenían identificadores que no fueran números correlativos, se copian como una variable extra llamada `rn` (de *rownames*).


* Importando un fichero externo con la función  `fread`, exactamente igual  como si usáramos `read.table`.
Algunas ventajas de `fread` son que detecta automáticamente los separadores de columnas y si el fichero contiene o no una primera fila con los nombres de las variables, aunque su ventaja principal es la rapidez: tablas de varios Gb, que con `read.table` tardan varias  horas en importarse, con  `fread` tardan pocos minutos. Es importante tener en cuenta que, al contrario que `read.table`, la función  `fread` importa por defecto las columnas de palabras como tales, y no como factores: esto se puede cambiar añadiendo `stringsAsFactors=TRUE`. 

Vamos a crear  un *data table* para ilustrar su manejo básico.
```{r}
#Instalamos y cargamos el paquete "data.table"
#...
library(data.table)
Letras=c("A","B","A","A","B","A","C","C","A","A")
Var1=c(3,7,5,9,3,6,5,2,4,9)
Var2=c(2.3,5.2,6.4,-2.2,1.6,7.1,3.2,-3.5,-2.7,1.8)
Var3=c(6.8,6.4,5.5,6.2,5.3,7.8,6.3,6.3,6.3,7.5)
DT=data.table(Letras,Var1,Var2,Var3)
DT
str(DT)
```


Una de las operaciones específicas más útiles para  *data tables* es la creación de índices (*keys*) a partir de una o varias variables; estos índices sirven para identificar las filas y agilizan las búsquedas y extracciones de filas. La manera de indexar un   *data table* es mediante la instrucción

`setkey(`*data table*`, `*variable1*`, `*variable2*`, ...)`.

El resultado visible de esta instrucción es que `R` reordena las filas del *data table* en orden creciente de la *variable1* y, en caso de empate, de la *variable2*, y así sucesivamente; las variables se han de entrar  con su nombre sin entrecomillar. Fijaos también en que `no igualamos`  el *data table* al resultado de `setkey`, simplemente le aplicamos esta función.

```{r}
setkey(DT,Letras,Var3)
DT
```
Vemos que las filas se han ordenado según su entrada en la variable `Letras` y, en los empates,  según su entrada en `Var3`. A partir de ahora, las búsquedas de filas con valores concretos en estas variables se realizaría mediante búsqueda binaria usando esta ordenación. Este método es mucho más eficiente que el  que usaría un *data frame* : visitaría toda la primera variable y generaría un vector de valores lógicos que indicara, para cada entrada, si cumple o no la condición;  visitaría toda la segunda variable y generaría un segundo vector de valores lógicos que indicara, para cada entrada, si cumple o no la condición; generaría un tercer vector que tuviera un `TRUE` en aquellas entradas que lo tuvieran en cada uno de los vectores anteriores; finalmente, daría las filas correspondientes a los `TRUE` en este último vector.

Una vez hemos indexado un *data table*, podemos usar las variables que hemos definido como índices para extraer filas. La conjunción de varias condiciones se indica con la función `J`; veamos varios ejemplos, observad la sintaxis:

```{r}
DT["B"]   #Filas con una B en Letras
DT[c("B","C")]  #Filas con una B o una C en Letras
DT[Letras>"A"]  #Filas con entrada mayor que A en Letras
DT[J("A",c(6.2,6.3))]  #Filas con A en Letras y 6.2 o 6.3 en Var3
```


La construcción `[\ ]` en los  *data tables* tiene un significado, y, por lo tanto, un uso diferente que en los *data frames* ; en general, el argumento dentro de los corchetes aplicados a un *data table* tiene tres partes, separadas por comas:

* La primera indica las filas, como ya hemos visto. Normalmente, para que el proceso sea eficiente, impondremos condiciones sobre las filas usando las variables definidas para indexar la tabla. Si dejamos esta posición vacía, se toman todas las filas.

* La segunda parte indica columnas, o, más en general, expresiones aplicadas a columnas, incluyendo operaciones u otro tipo de funciones: `plot`, `lm`\ldots\ Podemos usar los nombres de las variables, sin entrecomillar, o su número de orden: en este último caso, se ha de añadir `with=FALSE` en la tercera posición.
Si queremos extraer varias columnas de un  *data table* o efectuar varias operaciones, hay que especificarlas en esta segunda posición dentro de una  `list`. Si queremos sólo la primera o la última fila de una subtabla, se ha de especificar en esta segunda posición con \verb?mult="first"? o \verb?mult="last"?, respectivamente.

* La tercera precisa la expresión en la segunda posición: por ejemplo, si se ha de aplicar agrupando los datos (con el parámetro `by`) o cómo se han indicado las variables (con el parámetro `with`). Si queremos agrupar según una combinación de variables, tenemos que especificarlas en esta tercera posición dentro de una  `list`.

En resumen,

`DT[X, Y, by=Z]`

equivale a: <<En el *data table* `DT`, extrae las filas `X` y ejecuta  `Y` sobre sus columnas agrupando las filas según `Z`>>.


Veamos varios ejemplos:

```{r}
DT[ ,Var1]  #El contenido de Var1
DT[ ,2]  #Esto no es la segunda variable
DT[ ,2,with=FALSE] #Esto sí
DT[ ,list(Var1,Var2)]  #Un data table con las variables Var1 y Var2
DT["A",mult="first"] #La primera fila con A en Letras
DT["A",mult="last"] #La última fila con A en Letras
DT["A",sum(Var1)]  #Suma de Var1 de las filas con una A en Letras
DT[ ,sum(Var1),by=Letras]  #Suma de Var1 agrupando según el valor de Letras
DT[ ,list(sumas1=sum(Var1),medias1=mean(Var2)), 
  by=list(Letras,Var3)] #Suma de Var1 y media de Var2, agrupando según Letras y Var3
```
Para más ejemplos, consultad `example(data.table)`.

Para modificar una variable, o añadir una variable, podemos usar la construcción

`nombre` `:=``valor` 

en la segunda posición dentro de los corchetes; esta construcción sirve también para eliminar una variable, igualándola a `NULL`.
```{r}
DT[ ,Var4:=2*Var1+Var2]  #Añadimos esta nueva columna Var4
DT
DT["A",Var5:=3*Var4]   #Añadimos esta nueva columna Var5, sólo en las filas con una A en Letras
DT
```

## Guía rápida de funciones

* `data()` produce una lista con los objetos de datos a los que tenemos acceso.
* `View` muestra el *data frame* al que se aplica en la ventana superior izquierda de `Rstudio`.
* `head` aplicado a un *data frame* y un número $n$, nos muestra las primeras $n$ filas del *data frame* (por defecto, 6).
* `tail` aplicado a un *data frame* y un número $n$, nos muestra las  $n$ últimas filas del *data frame* (por defecto, 6).
* `str` da la estructura global de un objeto de datos.
* `names` sirve para obtener un vector con los nombres de las columnas de un *data frame*, y también para modificar estos nombres.
* `rownames` sirve para obtener  un vector con los identificadores de las filas  de un *data frame*, y también para modificar estos identificadores. 
* `dimnames` sirve para obtener  una `list` formada por el vector de los identificadores de las filas y el vector de los nombres de las columnas de un *data frame*, y también para modificar estos vectores simultáneamente.
* `dim` da el número de filas y el número de columnas de un *data frame* 
* *data frame* `\$``variable`  indica la `variable`  del *data frame*
* `read.table` permite importar un fichero externo  en formato texto simple en un *data frame* Algunos parámetros importantes:
* `sep`: sirve para indicar los separadores de las columnas.
* `header`: sirve para indicar si el fichero a importar  tiene una primera fila con los nombres de las variables o no.
* `dec`: sirve para especificar el separador decimal.
* `stringsAsFactors`: igualado a `FALSE`, impone que las columnas de palabras se importen como tales, y no como factores.
* `encoding`:  indica la codificación de alfabeto del fichero externo.
* `read.csv`, `read.xls`, `read.xlsx` (ambas del paquete `xlsx`), `read.mtb` y `read.spss`  (ambas del paquete `foreign`) permiten importar en un *data frame* una tabla de datos en formato CSV, XLS, XLSX, Minitab o SPSS, respectivamente.
* `write.table(`*data frame* `,file="`*fichero*`")` exporta el *data frame* al *fichero* externo.
* `data.frame` crea un *data frame* con los vectores a los que se aplica. Algunos parámetros importantes:
  + `rownames`: sirve para especificar los identificadores de las filas.
  + `stringsAsFactors`: como en `read.table`.
* `fix` abre un objeto de datos en el editor de datos.
* `paste(`$x_1$`, `$x_2$`,...., sep="*separador*")` pega los vectores $x_1$, $x_2$, \ldots, entrada a entrada, usando como separador el valor del parámetro `sep`.
* `as.character`, `as.integer` y `as.numeric` transforman todos los datos de un objeto en palabras, números enteros o números reales, respectivamente.
* `droplevels` borra todos los niveles sobrantes de todos los factores de un *data frame*
* `select`, del paquete `dplyr`, permite definir un *data frame*  con todas las variables de un *data frame* que empiecen por una secuencia de letras dada (con el parámetro `starts_with`), que terminen por una secuencia de letras dada (con el parámetro `ends_with`), o que contengan una secuencia de letras dada (con el parámetro `contains`).
* `subset(`*data frame* `, ``condición` `, select=``columnas` `)` define un *data frame* con las filas del *data frame* que cumplen la `condición` y las columnas especificadas en el parámetro `select`.
* `sapply(`*data frame* `, FUN=``función` `)` aplica la `función`  a las columnas de un *data frame*
* `aggregate` sirve para aplicar una función a una o varias variables de un *data frame* agrupando sus entradas por los niveles de uno o varios factores.
* `attach` añade las variables de un *data frame* al entorno global de `R`.
* `detach` deshace el efecto de `attach`.
* `data.table`, del paquete `data.table`, crea un *data table* a partir de vectores o de un *data frame*
* `fread`, del paquete `data.table`,  permite importar un fichero externo en un *data table*.
* `setkey`, del paquete `data.table`,  indexa un *data table*.
* `[1, 2, by=3]`, aplicado a un  `data.table`, extrae las filas especificadas en la posición `1` y ejecuta  la expresión `2` sobre sus columnas, agrupando las filas según la condición `3`.

## Ejercicio

 La tabla de datos `pulse.txt` que encontraréis en [http://aprender.uib.es/Rdir/pulse.txt](http://aprender.uib.es/Rdir/pulse.txt)  recoge una serie de informaciones de tipo general (altura, peso, sexo, si corren, si fuman y su nivel de actividad física: 1 si es bajo, 2 si es moderado y 3 si es alto) sobre algunos estudiantes matriculados en un curso de estadística de la Universidad Estatal de Pensilvania hace unos  años. A estos estudiantes se les pidió que lanzasen una moneda  al aire: a los que sacaron cara, se les hizo correr un minuto sin moverse del sitio, y los que sacaron cruz, descansaron un minuto. Todos los estudiantes (tanto los que corrieron como los que no) midieron sus pulsaciones por minuto antes y después de este minuto de ejercicio o descanso, y estas medidas también aparecen en esta tabla (en las variables `PuBefor` y `PuAfter`, respectivamente).


a.  ¿Cuántos  estudiantes tomaron parte en este estudio? ¿Cuántos son hombres y cuántas mujeres?

b. Calculad el porcentaje medio de variación en el número de pulsaciones tras el minuto de ejercicio o descanso de los estudiantes que corrieron (se indica con el valor `yes` en la variable `Ran.`) y de los que no. ¿Hay mucha diferencia?

c. Calculad el porcentaje medio  de incremento en el número de pulsaciones tras el minuto de ejercicio sólo para los estudiantes que corrieron, pero ahora distinguiendo los hombres de las mujeres. ¿Cuál de los dos incrementos medios es mayor?

d. Calculad el porcentaje medio de incremento en el número de pulsaciones tras el minuto de ejercicio para los estudiantes  que corrieron, pero ahora distinguiendo los estudiantes que fuman de los que no. ¿Cuál de los dos incrementos medios es mayor?

e. Calculad el número medio de pulsaciones antes del minuto de ejercicio o descanso de todos los estudiantes, separados según su nivel de actividad física. ¿Se observa alguna diferencia significativa?

